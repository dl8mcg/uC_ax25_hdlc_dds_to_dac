/*
 * timer.c
 *
 * Created: 03.02.2026
 * Modified: 12.02.2026
 * Author: DL8MCG
 */ 

#include <avr/pgmspace.h>
#include <stdbool.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include "timer.h"
#include "board.h"
#include "hdlc_irq.h"

#define prescaler 8

#define F_SAMPLE 76800		// Abtasttakt in Hz (sample frequency)

#define F_SYMBOL 1200		// 1200 bps AFSK (symbolrate)

#define F1 1200				// DDS-Frequenz F1 in Hz
#define F2 2200				// DDS-Frequenz F2 in Hz

///************** DDS phase accu ***********************/
volatile uint32_t dds_phase_accu;
volatile uint32_t dds_phase_increment_f1; 
volatile uint32_t dds_phase_increment_f2; 
volatile bool freq;

volatile uint8_t hdlc_cnt; 

const uint8_t sinetab[] PROGMEM =   // 256 elements
{
	0x80,0x83,0x86,0x89,0x8c,0x8f,0x92,0x95,0x98,0x9c,0x9f,0xa2,0xa5,0xa8,0xab,0xae,
	0xb0,0xb3,0xb6,0xb9,0xbc,0xbf,0xc1,0xc4,0xc7,0xc9,0xcc,0xce,0xd1,0xd3,0xd5,0xd8,
	0xda,0xdc,0xde,0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xed,0xef,0xf0,0xf2,0xf3,0xf5,
	0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfc,0xfd,0xfe,0xfe,0xff,0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0xfe,0xfd,0xfc,0xfc,0xfb,0xfa,0xf9,0xf8,0xf7,
	0xf6,0xf5,0xf3,0xf2,0xf0,0xef,0xed,0xec,0xea,0xe8,0xe6,0xe4,0xe2,0xe0,0xde,0xdc,
	0xda,0xd8,0xd5,0xd3,0xd1,0xce,0xcc,0xc9,0xc7,0xc4,0xc1,0xbf,0xbc,0xb9,0xb6,0xb3,
	0xb0,0xae,0xab,0xa8,0xa5,0xa2,0x9f,0x9c,0x98,0x95,0x92,0x8f,0x8c,0x89,0x86,0x83,
	0x80,0x7c,0x79,0x76,0x73,0x70,0x6d,0x6a,0x67,0x63,0x60,0x5d,0x5a,0x57,0x54,0x51,
	0x4f,0x4c,0x49,0x46,0x43,0x40,0x3e,0x3b,0x38,0x36,0x33,0x31,0x2e,0x2c,0x2a,0x27,
	0x25,0x23,0x21,0x1f,0x1d,0x1b,0x19,0x17,0x15,0x13,0x12,0x10,0x0f,0x0d,0x0c,0x0a,
	0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x03,0x02,0x01,0x01,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x02,0x03,0x03,0x04,0x05,0x06,0x07,0x08,
	0x09,0x0a,0x0c,0x0d,0x0f,0x10,0x12,0x13,0x15,0x17,0x19,0x1b,0x1d,0x1f,0x21,0x23,
	0x25,0x27,0x2a,0x2c,0x2e,0x31,0x33,0x36,0x38,0x3b,0x3e,0x40,0x43,0x46,0x49,0x4c,
	0x4f,0x51,0x54,0x57,0x5a,0x5d,0x60,0x63,0x67,0x6a,0x6d,0x70,0x73,0x76,0x79,0x7c
};

void init_DDS()
{  
	// Formel: Increment = (f_out / f_sample) * 2^32  	// 2^32 = 4294967296.0
	dds_phase_increment_f1 = (F1 * 4294967296.0) / F_SAMPLE;
	dds_phase_increment_f2 = (F2 * 4294967296.0) / F_SAMPLE;
}

void toggle_freq()
{
	freq ^= 1;						// Frequenz wechseln, zwischen DDS-Frequenz F1 und F2 (FSK)
}

void init_timer_ctc()
{
	// Timer1 konfigurieren (16-Bit Timer) im CTC-Modus
	TCCR1B |= (1 << WGM12);			// CTC-Modus aktivieren
	TCCR1B |= (1 << CS11);			// Prescaler auf 8 setzen, CS10 und CS12 auf 0 setzen
	TIMSK |= (1 << OCIE1A);			// Output Compare Match A Interrupt aktivieren
	
	// Vergleichswert für CTC-Modus setzen, damit alle 1/F_SAMPLE s ein Interrupt ausgelöst wird
	volatile static uint32_t ctc_divider;
	ctc_divider = F_CPU/prescaler/(F_SAMPLE) - 1;
	OCR1A = ctc_divider;
}

ISR(TIMER1_COMPA_vect)					// IRQ CTC-Timer
{
	DAC = pgm_read_byte(&sinetab[(uint8_t)(dds_phase_accu >> 24)]);		// sample-Wert aus Sinus-Tabelle holen und in R2R-DAC ausgeben
	if(freq)
		dds_phase_accu += dds_phase_increment_f2;		// phase-increment für FSK-Frequenz F2
	else
		dds_phase_accu += dds_phase_increment_f1;		// phase-increment für FSK-Frequenz F1
	
	if(hdlc_cnt)	
		hdlc_cnt--;
	else	
	{
		smFSK();										// nächstes HDLC-Bit 
		hdlc_cnt = F_SAMPLE / F_SYMBOL;
	}
}






